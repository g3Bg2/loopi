import { app, BrowserWindow, ipcMain } from "electron";
import axios from "axios";
// Fix for Linux sandbox issues - must be before any app initialization
if (process.platform === "linux") {
  app.commandLine.appendSwitch("--no-sandbox");
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let browserWin: BrowserWindow | null = null;
let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  mainWindow = new BrowserWindow({
    height: 800,
    width: 1100,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      webviewTag: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();
};

ipcMain.handle("browser:open", async (_event, url: string) => {
  if (browserWin) return;

  browserWin = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
    },
  });

  await browserWin.loadURL(url);
  browserWin.on("closed", () => {
    browserWin = null;
    // Notify the main window that the browser has closed
    if (mainWindow) {
      mainWindow.webContents.send("browser:closed");
    }
  });
});

ipcMain.handle("browser:close", () => {
  if (browserWin) {
    browserWin.close();
    browserWin = null;
    // Notify the main window that the browser has closed
    if (mainWindow) {
      mainWindow.webContents.send("browser:closed");
    }
  }
});

ipcMain.handle("browser:runStep", async (_event, step) => {
  if (!browserWin) return;

  const wc = browserWin.webContents;

  switch (step.type) {
    case "navigate":
      await wc.loadURL(step.value);
      break;
    case "click":
      await wc.executeJavaScript(`
        document.querySelector("${step.selector}")?.click();
      `);
      break;
    case "type":
      await wc.executeJavaScript(`
        const el = document.querySelector("${step.selector}");
        if (el) { el.focus(); el.value = "${step.value}"; el.dispatchEvent(new Event('input', { bubbles: true })); }
      `);
      break;
    case "wait":
      await new Promise((res) => setTimeout(res, parseInt(step.value) * 1000));
      break;
    case "screenshot":
      const img = await wc.capturePage();
      return img.toPNG().toString("base64");
    case "extract":
      return await wc.executeJavaScript(`
        document.querySelector("${step.selector}")?.innerText || "";
      `);
    case "extractWithLogic":
      const extractedValue = await wc.executeJavaScript(`
        document.querySelector("${step.selector}")?.innerText || "";
      `);
      let conditionMet = false;
      if (step.condition === "equals") {
        conditionMet = extractedValue === step.expectedValue;
      } else if (step.condition === "contains") {
        conditionMet = extractedValue.includes(step.expectedValue);
      } else if (step.condition === "greaterThan") {
        conditionMet =
          parseFloat(extractedValue) > parseFloat(step.expectedValue);
      } else if (step.condition === "lessThan") {
        conditionMet =
          parseFloat(extractedValue) < parseFloat(step.expectedValue);
      }
      return { value: extractedValue, conditionMet };
    case "repeat":
      const elements = await wc.executeJavaScript(`
        Array.from(document.querySelectorAll("${step.selector}")).slice(0, ${step.repeatCount || Infinity});
      `);
      const results = [];
      for (let i = 0; i < elements.length; i++) {
        for (const subStep of step.subSteps || []) {
          const result = await executeSubStep(wc, subStep, i);
          results.push(result);
        }
      }
      return results;
    case "apiCall":
      try {
        const response = await axios({
          method: step.method || "GET",
          url: step.url,
          data: step.body ? JSON.parse(step.body) : undefined,
          headers: step.headers || {},
        });
        return response.data;
      } catch (error) {
        console.error("API call failed:", error);
        throw error;
      }
    case "conditional":
      let conditionResult = false;
      if (step.conditionType === "elementExists") {
        conditionResult = await wc.executeJavaScript(`
          !!document.querySelector("${step.selector}");
        `);
      } else if (step.conditionType === "valueMatches") {
        const value = await wc.executeJavaScript(`
          document.querySelector("${step.selector}")?.innerText || "";
        `);
        conditionResult = value === step.expectedValue;
      }
      const stepsToExecute = conditionResult ? step.thenSteps : step.elseSteps;
      const conditionalResults = [];
      for (const subStep of stepsToExecute || []) {
        const result = await executeSubStep(wc, subStep);
        conditionalResults.push(result);
      }
      return conditionalResults;
    case "scroll":
      if (step.scrollType === "toElement") {
        await wc.executeJavaScript(`
          const el = document.querySelector("${step.selector}");
          if (el) el.scrollIntoView({ behavior: "smooth" });
        `);
      } else if (step.scrollType === "byAmount") {
        await wc.executeJavaScript(`
          window.scrollBy(0, ${step.scrollAmount || 0});
        `);
      }
      break;
    case "selectOption":
      await wc.executeJavaScript(`
        const select = document.querySelector("${step.selector}");
        if (select) {
          ${
            step.optionValue
              ? `select.value = "${step.optionValue}";`
              : `select.selectedIndex = ${step.optionIndex || 0};`
          }
          select.dispatchEvent(new Event('change', { bubbles: true }));
        }
      `);
      break;
    case "fileUpload":
      await wc.executeJavaScript(`
        const input = document.querySelector("${step.selector}");
        if (input) {
          const file = new File([""], "${step.filePath}", { type: "text/plain" });
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(file);
          input.files = dataTransfer.files;
          input.dispatchEvent(new Event('change', { bubbles: true }));
        }
      `);
      break;
    case "hover":
      await wc.executeJavaScript(`
        const el = document.querySelector("${step.selector}");
        if (el) {
          const event = new MouseEvent('mouseover', { bubbles: true });
          el.dispatchEvent(event);
        }
      `);
      break;
  }
});

async function executeSubStep(wc: any, step: any, index?: number) {
  switch (step.type) {
    case "click":
      return await wc.executeJavaScript(`
        document.querySelectorAll("${step.selector}")[${index || 0}]?.click();
      `);
    case "type":
      return await wc.executeJavaScript(`
        const el = document.querySelectorAll("${step.selector}")[${index || 0}];
        if (el) { el.focus(); el.value = "${step.value}"; el.dispatchEvent(new Event('input', { bubbles: true })); }
      `);
    case "extract":
      return await wc.executeJavaScript(`
        document.querySelectorAll("${step.selector}")[${index || 0}]?.innerText || "";
      `);
    default:
      return null;
  }
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
